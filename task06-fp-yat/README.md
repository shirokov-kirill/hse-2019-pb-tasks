# Функциональное программирование II (`task06-fp-yat`)
## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Общее](#общее)
    1. [Описание языка ЯТЬ](#описание-языка-ЯТЬ)
    1. [Пример программы](#пример-программы)
    1. [Комментарии к заданию](#комментарии-к-заданию)
    1. [Часть 1: `showProgram`](#часть-1-showProgram)
    1. [Часть 2: `evaluate`](#часть-2-evaluate)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Блокирующее](#блокирующее)
    1. [Формат представления](#формат-представления)
    1. [Советы по решению](#советы-по-решению)
1. [Бонусное задание](#бонусное-задание)
1. [Сдача задания](#сдача-задания)
    1. [Процесс](#процесс)
    1. [Сроки](#сроки)
    1. [Система оценки](#система-оценки)
    
## Задание
### Общее
В этом задании вам требуется написать несколько функций, работающие
с программами на искусственном языке программирования "ЯТЬ".
ЯТЬ — императивный язык программирования с переменными,
единственный тип данных — целое число,
любое выражение возвращает значение,
области видимости переменных — динамические
(а не лексические, как в популярных языках общего назначения).

Вам уже даны базовые объявления типов данных, описывающих программу
на ЯТЬ, а также некоторые вспомогательные функции.
Их менять запрещается.

Это задание состоит из двух независимых частей, ни одна из частей не 
является блокирующей. В каждой части вам потребуется реализовать недостающие 
функции. Для них уже написаны типовые аннотации и объявления, но вместо 
реализации написано `undefined`. Вам необходимо убрать `undefined` и добавить
реализацию этих функций.

Гарантируется, что во всех тестах все `Reference` относятся только
к существующим на момент выполнения переменным, а все `FunctionCall`
вызывают только существующие функции.
Тем не менее, Haskell потребует от вас обработать эти случаи,
возвращайте специальное значение `undefined` (если попытаться
его вычислить или с чем-нибудь сравнить, программа падает).

### Описание языка ЯТЬ
Программа на языке ЯТЬ (`Program`) состоит из нескольких определений
функций (`FunctionDefinition`) с разными именами и основного тела программы (`Body`).
Любая функция может вызвать любую другую, в том числе рекурсивно.

Некоторые языки программирования различают _выражения_ (expression) и _инструкции_ (statement),
в ЯТЬ такого различия нет.
Любое выражение в ЯТЬ возвращает некоторое целочисленное значение.
Любое выражение может являться частью другого выражения.
Существует специальное выражение `Block`, которое вычисляет
несколько других выражений подряд (фигурные скобки).

Тело программы или функции — это одно выражение типа `Expression`.
Состояние интерпретатора `State` — это набор видимых в данной точке программы имён
переменных и их значений (область видимости, scope).
Scope может изменяться при выполнении выражения `Assign` (присваивание переменной).
Новые scope создаются в двух случаях: при запуске программы и
при вызове функции (выражение `FunctionScope`).

Подробное описание возвращаемых значений и побочных эффектов вычислений
различных выражений доступно в комментариях в файле `Yat.hs`.

### Пример программы
Разберём программу `program3` из `Main.hs`.
Она представляется следующим образом:

```
func f(param) = {
	let a = (a + 1) tel;
	let param = (param + 1) tel;
	(((a * 100) + (b * 10)) + param)
}
{
	let a = 2 tel;
	let b = 7 tel;
	let res = f((1 + !let a = 3 tel)) tel;
	let b = (b + 1) tel;
	(((res * 100) + (b * 10)) + a)
}
```

Выполнение происходит так:

1. Создаётся пустой scope `X = {}`.
1. Присваиваются значения переменных: `X = {a: 2, b: 7}`.
1. Перед вызовом функции `f` вычисляются все аргументы: `X = {a: 3, b: 7}`, а значение
   аргумента равно `1 + !3 = 1 + 0 = 1`.
1. Для вызова функции `f` есть создаётся новый scope — копия `X`, в которую добавили вычисленные значения параметров: `Y = {a: 3, b: 7, param: 1}`,
1. Функция `f` меняет свой scope на `Y = {a: 4, b: 7, param: 2}` и возвращает значение `472`.
1. После окончания работы `f` основная программа обновляет свой scope: `X = {a: 3, b: 7, res: 472}`.
1. Выполняются оставшиеся команды: `X = {a: 3, b: 8, res: 474}` и возвращается значение `47283`.

### Комментарии к заданию
* То, что вызываемая функция `f` видит все переменные вызвавшего кода, чем-то похоже
  на [динамические области видимости](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8#%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_vs._%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8).
  Отличие — в языке ЯТЬ вызываемая функция в принципе не может изменить переменные вызывавшего кода.
* "Всё есть значение" и "блок возвращает последнее значение" — часто встречающиеся концепции.
  Например, в Scala и Kotlin из-за этого вообще нет тернарного оператора, его заменяет простой `if`.
* По-хорошему в случае ошибки надо не возвращать `undefined`, а явно указывать
  в сигнатуре функции, что она может завершиться с ошибкой:
  `eval :: Program -> Maybe Integer` вместо `eval :: Program -> Integer`.
* Вместо списка из пар для представления состояния лучше использовать
  `Data.Map.Strict`, заодно получится больше полезных функций "из коробки".
* Самодельные вспомогательные функции в бонусном задании переизобретают монады.
  В хорошей программе на Haskell вместо них использовались бы встроенные.

### Часть 1: `showProgram`
Реализуйте функцию `showProgram`, которая возвращает текстовое представление `Program`.
Подробное описание формата вывода доступно [ниже](#формат-представления).

Цель этой части — познакомить вас с используемыми структурами данных.

### Часть 2: `evaluate`
Реализуйте функцию `evaluate`, которая выполняет программу на языке "ЯТЬ" и возвращает
вычисленное значение.

Цель этой части — продемонстрировать удобство обработки большого количества
случаев при помощи pattern matching и научить вас работать с изменяемым
состоянием в Haskell.
  
## Требования к корректности решения
### Блокирующее
Если в какой-то части не проходят тесты из условия, то эта часть автоматически оценивается в 0 баллов.
Попробуйте вбить в терминал `ghci RunTest.hs` и ввести команду `main`, чтобы запустить тесты 
автоматически.

Если хотя бы одно из следующих требований не выполняется, вы можете получить не более 30% баллов за задание:
1. Отсутствуют измения файлов кроме `Yat.hs`.
1. Типы и названия функций в заданиях не изменены.
1. Команда `ghc -W -Wno-unused-matches -Wno-unused-imports Yat.hs` компилирует модуль без warning'ов.
1. Все реализованные за вас функции оставлены без изменений.

### Формат представления
В возвращаемом значении `showProgram`:

* Отсутствуют пустые строчки.
* Отсутствуют `\n` в начале и в конце.

Представление программы начинается с представления всех функций (на отдельных строчках),
за которыми следует представление основного тела программы.

Функция с именем `f`, параметрами `a1`, `a2`, `a3` и телом `b` представляется
как строчка `func f(a1, a2, a3) = b`.

Выражения представляются рекурсивно.
Выражение может представляться как несколько строк,
в этом случае в начале и в конце представления отсутствуют `\n`.
Строго следуйте формату и [примеру](#пример-программы),
не допускаются отклонения в скобках, пробельных символах, отступах.

* `Number n` представляется как `n` в обычной десятичной записи.
* `Reference name` представляется как строчка `name`.
* `Assign name e` представляется как `let name = e tel`, где `name` — имя переменной, а представление `e` вычисляется рекурсивно.
* `BinaryOperation op l r` представляется как `(l op r)`, где `l` и `r` — рекурсивно вычисленные представления,
  а `op` — символ бинарной операции.
* `UnaryOperation op e` представляется как символ унарной операции, сразу за которым (без пробелов и скобок) записано
  представление выражения `e`.
* `FunctionCall name [e1, e2, e3]` представляется как `name(e1, e2, e3)`, где `name` — имя функции,
  а `e1`, `e2`, `e3` — рекурсивно вычисленные представления аргументов.
  Если аргумент один, запятых не ставится: `name(e1)`.
  Если аргументов ноль, скобки остаются: `name()`.
* `Conditional e t f` представляется как `if e then t else f fi`, где `e`, `t` и `f` — рекурсивно вычисленные представления.
* `Block [a1, a2, a3, ...]` представляется как `{` на отдельной строке, дальше на отдельных строках
  идут рекурсивно вычисленные представления `a1`, `a2`, `a3`, ..., после чего на отдельной строке идёт `}`.
  Между каждым `a1`, `a2`, `a3`, ..., кроме последнего, и соответствующим переводом строки
  расположен символ `;`.
  Все строчки между `{` и `}` должны иметь дополнительный отступ в один Tab (`\t`).

Блоки могут вкладываться, в этом случае отступы тоже складываются (см. `program4`):
```
{
	(a + if {
		(let a = 3 tel * 4);
		a
	} then 4 else {
		{
		};
		{
			let b = let c = 5 tel tel
		};
		{
		}
	} fi)
}
```

### Советы по решению
Заводите вспомогательные функции с хорошими названиями в глобальной области видимости.
Так их будет проще тестировать.

Не следует заводить отдельные функции на каждый случай pattern matching.

Старайтесь не писать сложные выражения как тело функции.

## Бонусное задание
Реализуйте часть 2 (`evaluate`) через вспомогательные функции наподобие `~~>` из предыдущего задания,
которые возвращают `type Eval a = [FunctionDefinition] -> State -> (a, State)`.
Здесь `Eval a` — функция, выполняющая программу на ЯТЬ и возвращающая значение типа `a`
(например, результат выполнения программы, но необязательно).

Эти вспомогательные функции и их сигнатуры описаны в файле `Yat.hs`.

Цель этой части — вывести вашими руками основные функции высшего порядка,
использумые в Haskell для вычислений с побочными эффектами.

## Сдача задания
### Процесс
Задание сдаётся **только** через систему Pull Request в GitHub, см. детальное описание
процесса в папке `common`. Ветку следует назвать `task06-fp-yat`.
Название Pull Request: `Task06-fp-yat, GroupXX, Фамилия Имя`.

Если вы сдаёте с нарушением процесса (например, неверный заголовок Pull Request),
то ваша посылка может быть не проверена, пока вы не исправите формат.

### Сроки
Задание выдано 01.02.2020 (суббота).

Срок сдачи — **11.02.2020 (вторник) 22:59 по Москве**.

К сроку сдачи требуется исправить все замечания преподавателя.

## Система оценки
Задание оценивается в 10 баллов:

| Часть | Корректность | Стиль кода  |
| ----- | ------------ | ------------|
| 1 | 1,5 | 1,5 |
| 2 | 3,5 | 3,5 |
| **Итого** | **10** | **10** |
| Бонус | 2,5  | 2,5  |

В каждой группе независимо устанавливаются баллы за частичную корректность и стиль.

Баллы набранные в посылке после срока сдачи, добавляются с коэффициентом 40%.
Например, если до срока сдачи вы получили 3 балла за корректность и 4 за стиль
(в сумме 7), а после срока сдачи — 5 за корректность и 3 за стиль (в сумме 8),
то вы получаете 7.4 балла за задание.

Если вы до дедлайна сделали посылку, и преподаватель считает, что недостатки в ней
не фатальны, вам может быть дана дополнительная попытка сдачи для исправления без штрафов.
Она должна быть явно разрешена вашим преподавателем.
Вы можете сделать её в течении 7 суток после проверки последней посылки.
